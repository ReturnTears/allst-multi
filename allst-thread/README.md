# 线程
```text
1、为什么需要多线程
CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，
主要体现为: 
    CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题  
    操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题
    编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题

2、
```

# 线程池
```text

⭐线程池基础
♦概念介绍
1、什么是线程池？
什么是池？生活中的池就是一种用于盛放的容器
线程池其实就是一种多线程处理形式，吹过程中可以将人物添加到队列中，然后再创建线程后自动启动这些任务。
这里的线程就是我们前面学过的线程，这里的任务就是我们起那面学过的实现了Runnable或Callable接口的实例对象。
2、为什么使用线程池？
生活中的汽车拥堵现象， 因此车管所会对汽车进行限号管理
使用线程池最大的原因就是可以根据系统的需求和硬件环境灵活的控制线程的数量，且可以对所有线程进行统一的管理和控制。
从而提高系统的运行效率，降低系统的运行压力，当然，使用线程池的原因不仅仅只有这些，我们可以从线程池自身的优点上来进一步了解线程池的好处。
3、线程池有那些优势？
1）、线程和任务分离，提升线程重用性
2）、控制线程并发数量，降低服务器压力，统一管理所有线程
3）、提升系统响应速度，假如创建线程用的时间为T1,执行任务用的时间为T2,销毁线程用的时间为T3,那么使用池就免去了T1和T3的时间。
4、线程池应用场景
🌂 网购商品秒杀、云盘文件上传和下载、12306网上购票系统等
🌂 只要有并发的敌法，任务数量大或小，每个任务执行时间长或短的都可以使用线程池。只不过在使用线程池的时候，注意一下设置合理的线程大小即可


⭐线程池使用
● Java内置线程池
❀ Java内置线程池原理剖析
   只有先了解了线程池的工作原理，我们才能自己定义线程池
● 自定义线程池
❀自定义线程池-参数设计分析
☀通过观察Java的内置线程池参数讲解和线程池工作流程总结， 我们不难发现，要设计一个好的线程池就必须要合理的设置线程池的4个参数：
  4个参数的设计
  🐟核心线程数(corePoolSize):核心线程数的设计需要依据任务的处理时间和每秒产生的任务数量来确定8020原则
  🐟任务队列长度(workQueue):任务队列长度一般设计为：核心线程数÷单个任务执行时间*2即可
  🐟最大线程数(maximumPoolSize):最大线程数的设计除了需要参照核心线程数的条件外，还需要参照系统每秒产生的最大任务数决定。
    最大线程数 = （最大任务数 - 任务队列长度）×单个任务执行时间
    ==>> 最大线程数 = （1000 - 200）× 0.1 = 80
  🐟最大空闲时间(keepAliveTime):根据自己情况自行设置即可
❀自定义线程池-实现步骤
☀编写任务类（MyTask）,实现Runnable接口
☀编写线程类（MyWorker）,用于执行任务，需要持有所有任务
☀编写线程池类（MyThreadPool）,包含提交任务，执行任务的能力
☀编写测试类（MyTest）,创建线程池对象，提交多个任务测试

● 异步计算结果(Future)



⭐线程池综合案例

🏀 线程池总结:
  线程池的使用步骤可以归纳总结为五步:
  🍎 利用Executors工厂类的静态方法，创建线程池对象
  🍎 编写Runnable或Callable实现类的实例对象
  🍎 利用ExecutorService的submit方法或ScheduledExecutorService的schedule方法提交并执行线程任务
  🍎 如果由执行结果，则返回异步执行结果
  🍎 调用shutdown方法，关闭线程池
  
  

```

# Java线程 
```text
JMH: Java多线程测试工具
Windows下查看进程信息：
1、打开任务管理器
2、命令行 tasklist 或者 tasklist | findstr java
3、杀死进程：taskkill /F /PID 进程号 /F表示强制杀死 

Linux下查看Java进程：
1、jps 查看所有Java进程
2、jstack PID 查看某个Java进程的所有线程状态
3、jconsole 来查看某个Java进程中线程的运行情况(图像界面)
jconsole远程监控配置：
java -Djava.rmi.server.hostname="ip地址" -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port="连接端口"
-Dcom.sun.management.jmxremote.ssl=是否安全连接(true/false) -Dcom.sun.management.jmxremote.authenticate=是否认证(true/false) Java类
```

# Synchronized
```text
在应用Sychronized关键字时需要把握如下注意点：
1、一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；
2、每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
3、synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

对象锁：
🍌包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象

方法锁：
🍌synchronized修饰普通方法，锁对象默认为this

类锁:
🍌指synchronize修饰静态的方法或指定锁对象为Class对象
 

```

## Synchronized原理
```text
通过SynchronizedDemo编译后查看字节码指令.txt文件查看：

Monitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，
一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：
1、 monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待 
2、如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加 
3、这把锁已经被别的线程获取了，等待锁释放 

monitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，
    当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。

对象，对象监视器，同步队列以及执行线程状态之间的关系 查看图：
    对象_对象监视器_同步队列以及执行线程状态之间的关系.png
从图中可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，
当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。

可重入：
    若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。
    即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。

可重入锁：
    又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。

```