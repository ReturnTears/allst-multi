# 线程
```text
1、为什么需要多线程
CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，
主要体现为: 
    CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题  
    操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题
    编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题

2、
```

# 线程池
```text

⭐线程池基础
♦概念介绍
1、什么是线程池？
什么是池？生活中的池就是一种用于盛放的容器
线程池其实就是一种多线程处理形式，吹过程中可以将人物添加到队列中，然后再创建线程后自动启动这些任务。
这里的线程就是我们前面学过的线程，这里的任务就是我们起那面学过的实现了Runnable或Callable接口的实例对象。
2、为什么使用线程池？
生活中的汽车拥堵现象， 因此车管所会对汽车进行限号管理
使用线程池最大的原因就是可以根据系统的需求和硬件环境灵活的控制线程的数量，且可以对所有线程进行统一的管理和控制。
从而提高系统的运行效率，降低系统的运行压力，当然，使用线程池的原因不仅仅只有这些，我们可以从线程池自身的优点上来进一步了解线程池的好处。
3、线程池有那些优势？
1）、线程和任务分离，提升线程重用性
2）、控制线程并发数量，降低服务器压力，统一管理所有线程
3）、提升系统响应速度，假如创建线程用的时间为T1,执行任务用的时间为T2,销毁线程用的时间为T3,那么使用池就免去了T1和T3的时间。
4、线程池应用场景
🌂 网购商品秒杀、云盘文件上传和下载、12306网上购票系统等
🌂 只要有并发的敌法，任务数量大或小，每个任务执行时间长或短的都可以使用线程池。只不过在使用线程池的时候，注意一下设置合理的线程大小即可


⭐线程池使用
● Java内置线程池
❀ Java内置线程池原理剖析
   只有先了解了线程池的工作原理，我们才能自己定义线程池
● 自定义线程池
❀自定义线程池-参数设计分析
☀通过观察Java的内置线程池参数讲解和线程池工作流程总结， 我们不难发现，要设计一个好的线程池就必须要合理的设置线程池的4个参数：
  4个参数的设计
  🐟核心线程数(corePoolSize):核心线程数的设计需要依据任务的处理时间和每秒产生的任务数量来确定8020原则
  🐟任务队列长度(workQueue):任务队列长度一般设计为：核心线程数÷单个任务执行时间*2即可
  🐟最大线程数(maximumPoolSize):最大线程数的设计除了需要参照核心线程数的条件外，还需要参照系统每秒产生的最大任务数决定。
    最大线程数 = （最大任务数 - 任务队列长度）×单个任务执行时间
    ==>> 最大线程数 = （1000 - 200）× 0.1 = 80
  🐟最大空闲时间(keepAliveTime):根据自己情况自行设置即可
❀自定义线程池-实现步骤
☀编写任务类（MyTask）,实现Runnable接口
☀编写线程类（MyWorker）,用于执行任务，需要持有所有任务
☀编写线程池类（MyThreadPool）,包含提交任务，执行任务的能力
☀编写测试类（MyTest）,创建线程池对象，提交多个任务测试

● 异步计算结果(Future)



⭐线程池综合案例

🏀 线程池总结:
  线程池的使用步骤可以归纳总结为五步:
  🍎 利用Executors工厂类的静态方法，创建线程池对象
  🍎 编写Runnable或Callable实现类的实例对象
  🍎 利用ExecutorService的submit方法或ScheduledExecutorService的schedule方法提交并执行线程任务
  🍎 如果由执行结果，则返回异步执行结果
  🍎 调用shutdown方法，关闭线程池
  
  

```

# Java线程 
```text
线程状态：Thread.State是一个枚举类。一个线程在给定的时间点只能处于一种状态。
1、NEW : 尚未启动的线程处于此状态。
2、RUNNABLE ： 在JVM中执行的线程处于此状态。
3、BLOCKED ： 阻塞等待拿锁的线程处于此状态。
4、WAITING ： 无限期等待的线程处于此状态。
5、TIMED_WAITING ： 最大等待指定时间的线程处于此状态。
6、TERMINATED ： 已退出的线程处于此状态。

JMH: Java多线程测试工具
Windows下查看进程信息：
1、打开任务管理器
2、命令行 tasklist 或者 tasklist | findstr java
3、杀死进程：taskkill /F /PID 进程号 /F表示强制杀死 

Linux下查看Java进程：
1、jps 查看所有Java进程
2、jstack PID 查看某个Java进程的所有线程状态
3、jconsole 来查看某个Java进程中线程的运行情况(图像界面)
jconsole远程监控配置：
java -Djava.rmi.server.hostname="ip地址" -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port="连接端口"
-Dcom.sun.management.jmxremote.ssl=是否安全连接(true/false) -Dcom.sun.management.jmxremote.authenticate=是否认证(true/false) Java类

Linux下使用perf命令来监视Java程序运行过程中的上下文切换情况：
pref stat -e cpu-clock,task-clock,cs,cache-references,cache-misses java java类
其中，cs表示被监视程序的上下文切换次数

在Windows平台下，可以使用Windows自带的工具perfmon来监视Java程序运行过程中的上下文切换情况

对线程的监视
1、JDK自带的工具jvisualvm[8]可以实现对线程的监视，它适合在开发和测试环境下监视Java系统中的线程情况
2、jstack是一个命令行工具，通过它可以获取指定Java进程的线程信息
3、在Java 8中，还可以使用Java Mission Control（JMC）工具来监视Java线
```

# 多线程
```text

```

# Synchronized
```text
在应用Sychronized关键字时需要把握如下注意点：
1、一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；
2、每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
3、synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

对象锁：
🍌包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象

方法锁：
🍌synchronized修饰普通方法，锁对象默认为this

类锁:
🍌指synchronize修饰静态的方法或指定锁对象为Class对象
 

```

## Synchronized原理
```text
通过SynchronizedDemo编译后查看字节码指令.txt文件查看：

Monitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，
一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：
1、 monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待 
2、如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加 
3、这把锁已经被别的线程获取了，等待锁释放 

monitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，
    当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。

对象，对象监视器，同步队列以及执行线程状态之间的关系 查看图：
    对象_对象监视器_同步队列以及执行线程状态之间的关系.png
从图中可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，
当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。

可重入：
    若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。
    即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。

可重入锁：
    又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。

```

## JVM中锁的优化
```text
jdk1.6中对锁的实现引入了大量的优化，如:
1、锁粗化(Lock Coarsening)：就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。
2、锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在本线程的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。
3、轻量级锁(Lightweight Locking)：
    这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，
    取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。
    当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。
4、偏向锁(Biased Locking)：
    是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。
5、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。
    当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，
    当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。

锁的类型
在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。
锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)

自旋锁
引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。
在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，
为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。
为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。

自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，
相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，
就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。

可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)

自适应自旋锁
在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。
如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。
比如增加到100次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。
有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。

锁消除
    锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。
    意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。

锁粗化
    原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。
    在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，
    甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。

轻量级锁
    在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。
    它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。
    如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。
    上面介绍Java对象头也详细介绍过。在对象头中(Object Header)存在两部分。
    第一部分用于存储对象自身的运行时数据，HashCode、GC Age、锁标记位、是否为偏向锁...等。
    一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。
    另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。

偏向锁
    引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，
    多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。
    为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，
    会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和推出同步块时不需要进行CAS操作来加锁和解锁。 
    只需要简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。

锁的优缺点对比
    锁       优点                  缺点                  使用场景 
    偏向锁   【加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距】 【如果线程间存在锁竞争，会带来额外的锁撤销的消耗】 【适用于只有一个线程访问同步块的场景】
    轻量级锁 【竞争的线程不会阻塞，提高了响应速度】     【如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能】 【追求响应时间，同步块执行速度非常快】
    重量级锁 【线程竞争不适用自旋，不会消耗CPU】 【线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗】 【追求吞吐量，同步块执行速度较长】

```

## Synchronized与Lock
```text
synchronized的缺陷:
    1、效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时  
    2、不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活
    3、无法知道是否成功获得锁，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....


Lock解决相应问题
    lock(): 加锁
    unlock(): 解锁
    tryLock(): 尝试获取锁，返回一个boolean值
    tryLock(long,TimeUtil): 尝试获取锁，可以设置超时

    Synchronized只有锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。 
    多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。
    ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，
    然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。

ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。
```

## volatile
```text
相比Sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种解决可见性和有序性问题的方案。

🍎 volatile关键字的作用是什么?
1、防重排序
    操作系统可以对指令进行重排序
2、实现可见性
    可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。
3、保证原子性:单次读/写
    volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。

i++为什么不能保证原子性?
    对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，
    但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。
    i++其实是一个复合操作，包括三步骤：
    1、读取i的值
    2、对i加1
    3、将i的值写回内存。
    volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 

共享的long和double变量的为什么要用volatile?
    因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。
    因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。

🍑 volatile 的实现原理
1、volatile 可见性实现
   volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现: 
   1)、内存屏障，又称内存栅栏，是一个 CPU 指令。 
   2)、在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，                                                                                                         
       插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。

为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，
就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 

所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。

2、volatile 有序性实现
volatile 的 happens-before 关系
happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
例如：
    int a = 0;
    volatile boolean flag = false;
    线程A ： a = 1;            // 1
            flag = true;      // 2
    线程B ： if (flag)         // 3
            int i = a;        // 4
根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。
1)、根据程序次序规则：1 happens-before 2 且 3 happens-before 4。
2）、根据 volatile 规则：2 happens-before 3。
3）、根据 happens-before 的传递性规则：1 happens-before 4。

因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。


volatile 禁止重排序
为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。
Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。
JMM 会针对编译器制定 volatile 重排序规则表。

" NO " 表示禁止重排序。

为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。

在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
在每个 volatile 读操作的后面插入一个 LoadStore 屏障。

volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。

内存屏障            说明 
StoreStore 屏障   禁止上面的普通写和下面的 volatile 写重排序。 
StoreLoad 屏障    防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。 
LoadLoad 屏障     禁止下面所有的普通读操作和上面的 volatile 读重排序。 
LoadStore 屏障    禁止下面所有的普通写操作和上面的 volatile 读重排序。 

volatile 的应用场景

使用 volatile 必须具备的条件
1、对变量的写操作不依赖于当前值。
2、该变量没有包含在具有其他变量的不变式中。
3、只有在状态真正独立于程序内其他内容时才能使用 volatile。

1、状态标志
也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。  

2、一次性安全发布(one-time safe publication)
缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。
在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。
(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，
但是仍然会通过该引用看到不完全构造的对象)。

3、独立观察(independent observation)
安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。
一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。
然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。

4、volatile bean 模式
在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。
此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。
对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。

5、开销较低的读－写锁策略
volatile 的功能还不足以实现计数器。
因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。
如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。
安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。
如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。

6、双重检查(double-checked)
单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。
```

## 🍒 Remark
```text
通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码
```