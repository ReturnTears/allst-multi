# 线程
```text
1、为什么需要多线程
CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，
主要体现为: 
    CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题  
    操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题
    编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题

2、
```

# 线程池
```text

⭐线程池基础
♦概念介绍
1、什么是线程池？
什么是池？生活中的池就是一种用于盛放的容器
线程池其实就是一种多线程处理形式，吹过程中可以将人物添加到队列中，然后再创建线程后自动启动这些任务。
这里的线程就是我们前面学过的线程，这里的任务就是我们起那面学过的实现了Runnable或Callable接口的实例对象。
2、为什么使用线程池？
生活中的汽车拥堵现象， 因此车管所会对汽车进行限号管理
使用线程池最大的原因就是可以根据系统的需求和硬件环境灵活的控制线程的数量，且可以对所有线程进行统一的管理和控制。
从而提高系统的运行效率，降低系统的运行压力，当然，使用线程池的原因不仅仅只有这些，我们可以从线程池自身的优点上来进一步了解线程池的好处。
3、线程池有那些优势？
1）、线程和任务分离，提升线程重用性
2）、控制线程并发数量，降低服务器压力，统一管理所有线程
3）、提升系统响应速度，假如创建线程用的时间为T1,执行任务用的时间为T2,销毁线程用的时间为T3,那么使用池就免去了T1和T3的时间。
4、线程池应用场景
🌂 网购商品秒杀、云盘文件上传和下载、12306网上购票系统等
🌂 只要有并发的敌法，任务数量大或小，每个任务执行时间长或短的都可以使用线程池。只不过在使用线程池的时候，注意一下设置合理的线程大小即可


⭐线程池使用
● Java内置线程池
❀ Java内置线程池原理剖析
   只有先了解了线程池的工作原理，我们才能自己定义线程池
● 自定义线程池
❀自定义线程池-参数设计分析
☀通过观察Java的内置线程池参数讲解和线程池工作流程总结， 我们不难发现，要设计一个好的线程池就必须要合理的设置线程池的4个参数：
  4个参数的设计
  🐟核心线程数(corePoolSize):核心线程数的设计需要依据任务的处理时间和每秒产生的任务数量来确定8020原则
  🐟任务队列长度(workQueue):任务队列长度一般设计为：核心线程数÷单个任务执行时间*2即可
  🐟最大线程数(maximumPoolSize):最大线程数的设计除了需要参照核心线程数的条件外，还需要参照系统每秒产生的最大任务数决定。
    最大线程数 = （最大任务数 - 任务队列长度）×单个任务执行时间
    ==>> 最大线程数 = （1000 - 200）× 0.1 = 80
  🐟最大空闲时间(keepAliveTime):根据自己情况自行设置即可
❀自定义线程池-实现步骤
☀编写任务类（MyTask）,实现Runnable接口
☀编写线程类（MyWorker）,用于执行任务，需要持有所有任务
☀编写线程池类（MyThreadPool）,包含提交任务，执行任务的能力
☀编写测试类（MyTest）,创建线程池对象，提交多个任务测试

● 异步计算结果(Future)



⭐线程池综合案例

🏀 线程池总结:
  线程池的使用步骤可以归纳总结为五步:
  🍎 利用Executors工厂类的静态方法，创建线程池对象
  🍎 编写Runnable或Callable实现类的实例对象
  🍎 利用ExecutorService的submit方法或ScheduledExecutorService的schedule方法提交并执行线程任务
  🍎 如果由执行结果，则返回异步执行结果
  🍎 调用shutdown方法，关闭线程池
  
  

```

# Java线程 
```text
JMH: Java多线程测试工具
Windows下查看进程信息：
1、打开任务管理器
2、命令行 tasklist 或者 tasklist | findstr java
3、杀死进程：taskkill /F /PID 进程号 /F表示强制杀死 

Linux下查看Java进程：
1、jps 查看所有Java进程
2、jstack PID 查看某个Java进程的所有线程状态
3、jconsole 来查看某个Java进程中线程的运行情况(图像界面)
jconsole远程监控配置：
java -Djava.rmi.server.hostname="ip地址" -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port="连接端口"
-Dcom.sun.management.jmxremote.ssl=是否安全连接(true/false) -Dcom.sun.management.jmxremote.authenticate=是否认证(true/false) Java类
```

# Synchronized
```text
在应用Sychronized关键字时需要把握如下注意点：
1、一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；
2、每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
3、synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

对象锁：
🍌包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象

方法锁：
🍌synchronized修饰普通方法，锁对象默认为this

类锁:
🍌指synchronize修饰静态的方法或指定锁对象为Class对象
 

```