# java异步编程


◆ 1.1 异步编程概念与作用

>> 通过编写异步、非阻塞的代码，则可以使用相同的底层资源将执行切换到另一个活动任务，然后在异步处理完成后再返回到当前线程继续处理，从而提高系统性能

◆ 1.2 异步编程场景

>> 在Java中，每当我们需要执行异步任务时，可以直接开启一个线程来实现，也可以把异步任务封装为任务对象投递到线程池中来执行。在Spring框架中提供了@Async注解把一个任务异步化来进行处理

>> 有时候我们还需要在主线程等待异步任务的执行结果，这时候Future就派上用场了

>> 使用Future确实可以获取异步任务的执行结果，但是获取其结果还是会阻塞调用线程的，并没有实现完全异步化处理

>> CompletableFuture类允许以非阻塞方式和基于通知的方式处理结果，其通过设置回调函数方式，让主线程彻底解放出来，实现了实际意义上的异步处理

>> 使用CompletableFuture时，当异步单元返回futureB后，调用线程可以在其上调用whenComplete方法设置一个回调函数action，然后调用线程就会马上返回，等异步任务执行完毕后会使用异步线程来执行回调函数action，而无须调用线程干预

>> JDK8还引入了Stream，旨在有效地处理数据流（包括原始类型），其使用声明式编程让我们可以写出可读性、可维护性很强的代码，并且结合CompletableFuture完美地实现异步编程

>> Netty框架将网络编程逻辑与业务逻辑处理分离开来，在内部帮我们自动处理好网络与异步处理逻辑，让我们专心写自己的业务处理逻辑，而Netty的异步非阻塞能力与CompletableFuture结合则可以轻松地实现网络请求的异步调用

>> Servlet 3.0规范中则提供了异步处理的能力，让Servlet容器中的线程可以及时释放，具体Servlet业务处理逻辑是在业务自己的线程池内来处理

>> 使用少量线程和较少的硬件资源来处理并发的非阻塞Web技术栈应运而生—WebFlux，其是与Servlet技术栈并行存在的一种新技术，基于JDK8函数式编程与Netty实现天然的异步、非阻塞处理

>> 为了更好地处理异步编程，降低异步编程的成本，一些框架也应运而生，比如高性能线程间消息传递库Disruptor，其通过为事件（event）预先分配内存、无锁CAS算法、缓冲行填充、两阶段协议提交来实现多线程并发地处理不同的元素，从而实现高性能的异步处理

>> 比如Akka基于Actor模式实现了天然支持分布式的使用消息进行异步处理的服务

>> 比如高性能分布式消息中间件Apache RocketMetaQ实现了应用间的异步解耦、流量削峰

◆ 2.1 显式使用线程实现异步编程

>> 在Java中实现异步编程最简单的方式是：每当有异步任务要执行时，使用Tread来创建一个线程来进行异步执行

>> 使用lambda表达式创建了一个java.lang.Runnable接口的匿名实现类

>> Java中线程是有Deamon与非Deamon之分的，默认情况下我们创建的都是非Deamon线程，线程属于什么类型与JVM退出条件有一定的关系

◆ 2.2 显式使用线程池实现异步编程

>> 在Java中我们可以使用线程池来实现线程复用，每当我们需要执行异步任务时，可以把任务投递到线程池里进行异步执行

>> 线程池的拒绝策略设置为CallerRunsPolicy，即当线程池任务饱和，执行拒绝策略时不会丢弃新的任务，而是会使用调用线程来执行

>> 图2-1 线程池类图结构

>> RUNNING：接收新任务并且处理阻塞队列里的任务

>> SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务

>> STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时中断正在处理的任务

>> TIDYING：所有任务都执行完（包含阻塞队列里面任务），当前线程池活动线程为0，将要调用terminated方法

>> TERMINATED：终止状态。terminated方法调用完成以后的状态

>> RUNNING→SHUTDOWN：当显式调用shutdown()方法时，或者隐式调用了finalize()，它里面调用了shutdown()方法时

>> UNNING或者SHUTDOWN→STOP：当显式调用shutdownNow()方法时

>> SHUTDOWN→TIDYING：当线程池和任务队列都为空

>> STOP→TIDYING：当线程池为空时

>> TIDYING→TERMINATED ：当terminated() hook方法执行完成时

>> corePoolSize：线程池核心线程个数

>> workQueue：用于保存等待执行的任务的阻塞队列，比如基于数组的有界Array-BlockingQueue、基于链表的无界LinkedBlockingQueue、最多只有一个元素的同步队列SynchronousQueue、优先级队列PriorityBlockingQueue等

>> maximunPoolSize：线程池最大线程数量

>> threadFactory：创建线程的工厂类

>> defaultHandler：饱和策略，当队列满了并且线程个数达到maximunPoolSize后采取的策略，比如AbortPolicy（抛出异常）、CallerRunsPolicy（使用调用者所在线程来运行任务）、DiscardOldestPolicy（调用poll丢弃一个任务，执行当前任务）、DiscardPolicy（默默丢弃，不抛出异常）

>> keeyAliveTime：存活时间。如果当前线程池中的线程数量比核心线程数量要多，并且是闲置状态的话，这些闲置的线程能存活的最大时间

2023/05/09发表想法
AQS( Abstract Queued Synchronizer )是一个抽象的队列同步器,通过维护一个共享资源状态( Volatile Int State )和一个先进先出( FIFO )的线程等待队列来实现一个多线程访问共享资源
>> AQS

>> 当用户线程提交任务到线程池后，在线程池没有执行拒绝策略的情况下，用户线程会马上返回，而提交的任务要么直接切换到线程池中的Worker线程来执行，要么先放入线程池的阻塞队列里面，稍后再由Worker线程来执行

>> Worker构造函数内首先设置Worker的运行状态status为-1，是为了避免当前Worker在调用runWorker方法前被中断（当其他线程调用了线程池的shutdownNow时，如果Worker状态≥0则会中断该线程）

>> 线程池是通过池化少量线程来提供线程复用的，当调用线程向线程池中投递大量任务后，线程池可能就处于饱和状态了。所谓饱和状态是指当前线程池队列已经满了，并且线程池中的线程已经达到了最大线程个数。当线程池处于饱和状态时，再向线程池投递任务，而对于投递的任务如何处理，是由线程池拒绝策略决定的。拒绝策略的执行是在execute方法

>> 线程池中提供了RejectedExecutionHandler接口，用来提供对线程池拒绝策略的抽象

◆ 2.3 总结

>> 虽然线程池方式提供了线程复用可以获取任务返回值，但是获取返回值时还是需要阻塞调用线程的

◆ 3.1 JDK中的Future

>> 在Java并发包（JUC包）中Future代表着异步计算结果，Future中提供了一系列方法用来检查计算结果是否已经完成，也提供了同步等待任务执行完成的方法，还提供了获取计算结果的方法等

>> 当计算结果完成时只能通过提供的get系列方法来获取结果，如果使用了不带超时时间的get方法，则在计算结果完成前，调用线程会被一直阻塞。另外计算任务是可以使用cancel方法来取消的，但是一旦一个任务计算完成，则不能再被取消了

>> 等待异步计算任务完成，并返回结果

>> 相比get()方法多了超时时间，当线程调用了该方法后，在任务结果没有计算出来前调用线程不会一直被阻塞

>> 如果计算任务已经完成则返回true，否则返回false。需要注意的是，任务完成是指任务正常完成了、由于抛出异常而完成了或者任务被取消了

>> 尝试取消任务的执行

>> 如果任务在执行完毕前被取消了，则该方法返回true，否则返回false

◆ 3.2 JDK中的FutureTask

>> FutureTask代表了一个可被取消的异步计算任务，该类实现了Future接口，比如提供了启动和取消任务、查询任务是否完成、获取计算结果的接口

>> FutureTask任务的结果只有当任务完成后才能获取，并且只能通过get系列方法获取，当结果还没出来时，线程调用get系列方法会被阻塞。另外，一旦任务被执行完成，任务将不能重启，除非运行时使用了runAndReset方法。FutureTask中的任务可以是Callable类型，也可以是Runnable类型（因为FutureTask实现了Runnable接口）, FutureTask类型的任务可以被提交到线程池执行

>> FutureTask实现了Future接口的所有方法，并且实现了Runnable接口

>> 类图中outcome是任务运行的结果，可以通过get系列方法来获取该结果。另外，outcome这里没有被修饰为volatile，是因为变量state已经被volatile修饰了，这里是借用volatile的内存语义来保证写入outcome时会把值刷新到主内存，读取时会从主内存读取，从而避免多线程下内存不可见问题

◆ 3.4 JDK8Stream & CompletableFuture
```text

```

◆ 8.3 高性能线程间消息传递库—Disruptor

>> Disruptor是一个高性能的线程间消息传递库，它源于LMAX对并发性、性能和非阻塞算法的研究，如今构成了其Exchange基础架构的核心部分

