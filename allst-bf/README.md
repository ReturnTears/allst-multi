# Java 并发编程
[allst-thread](../allst-thread/README.md)

**并发三要素**

**1、可见性: CPU缓存引起**
```text
可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。
例：
    若变量T1=0，在多核CPU中，一个线程在CPU1上执行操作修改变量T1，这时CPU的操作是先将T1加载到高速缓存中，将T1=100,但是并没有写入到主存中。
    这时线程2在CPU2上执行操作也修改变量T1，同样是加载到高速缓存中，但是初始值还是0，这时候线程2修改的值是不正确的。
    这就是典型的可见性问题。
```
**2、原子性: 分时复用引起**
```text
原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
以下代码解读：
这里需要注意的是：i += 1需要三条 CPU 指令
1、将变量 i 从内存读取到 CPU寄存器； 
2、在CPU寄存器中执行 i + 1 操作； 
3、将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，
将造成最后写到内存中的i值是2而不是3。
```
```java
int i = 1;
// 线程1执行
i += 1;
// 线程2执行
i += 1;
```
**3、有序性: 重排序引起**
```text
有序性：即程序执行的顺序按照代码的先后顺序执行。
```
```java
int i = 0;              
boolean flag = false;
i = 1;                // 语句1  
flag = true;          // 语句2
```
```text
解读上述代码：
定义了两个不同类型的变量，然后对这两个变量赋值操作，从代码的顺序上看 语句1 是在 语句2前面的，
那么JVM在执行这段代码的时候能保证 语句1 在 语句2 前面执行吗？ 答案是：不一定， 因为这里有可能发生指令重排序（Instruction Reorder）

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 
1、编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 
2、指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 
3、内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：
查看图片：images/java-jmm-指令重排序.png
上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。
对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。
对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。
```

