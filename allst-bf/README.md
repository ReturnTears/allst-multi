# Java 并发编程
[allst-thread](../allst-thread/README.md)

**并发三要素**

**1、可见性: CPU缓存引起**
```text
可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。
例：
    若变量T1=0，在多核CPU中，一个线程在CPU1上执行操作修改变量T1，这时CPU的操作是先将T1加载到高速缓存中，将T1=100,但是并没有写入到主存中。
    这时线程2在CPU2上执行操作也修改变量T1，同样是加载到高速缓存中，但是初始值还是0，这时候线程2修改的值是不正确的。
    这就是典型的可见性问题。
```
**2、原子性: 分时复用引起**
```text
原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
以下代码解读：
这里需要注意的是：i += 1需要三条 CPU 指令
1、将变量 i 从内存读取到 CPU寄存器； 
2、在CPU寄存器中执行 i + 1 操作； 
3、将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，
将造成最后写到内存中的i值是2而不是3。
```
```java
int i = 1;
// 线程1执行
i += 1;
// 线程2执行
i += 1;
```
**3、有序性: 重排序引起**
```text
有序性：即程序执行的顺序按照代码的先后顺序执行。
```
```java
int i = 0;              
boolean flag = false;
i = 1;                // 语句1  
flag = true;          // 语句2
```
```text
解读上述代码：
定义了两个不同类型的变量，然后对这两个变量赋值操作，从代码的顺序上看 语句1 是在 语句2前面的，
那么JVM在执行这段代码的时候能保证 语句1 在 语句2 前面执行吗？ 答案是：不一定， 因为这里有可能发生指令重排序（Instruction Reorder）

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 
1、编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 
2、指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 
3、内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：
查看图片：images/java-jmm-指令重排序.png
上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。
对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。
对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。
```
**Java是怎么解决并发问题的：JMM**

**JMM相关**
(查看)[allst-note/note/book/README-JMM.md]
```text
JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。
这些方法包括(在JMM相关有详解)：
    volatile、synchronized 和 final 三个关键字
    Happens-Before 规则

可见性，有序性，原子性
【可见性】
Java提供了volatile关键字来保证可见性。 
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 
而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，
并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

【有序性】
在Java里面，可以通过volatile关键字来保证一定的“有序性”。
另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
当然JMM是通过 Happens-Before 规则来保证有序性的

【原子性】
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中
y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x = x + 1;     //语句4： 同语句3
上面4个语句只有语句1的操作具备原子性。
也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
```

**Happens-Before 规则**
```text
上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成.

单一线程原则
    在一个线程内，在程序前面的操作先行发生于后面的操作。

管程锁定规则
    一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

volatile 变量规则
    对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

线程启动规则
    Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

线程加入规则
    Thread 对象的结束先行发生于 join() 方法返回。

线程中断规则
    对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

对象终结规则
    一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。
    
传递性
    如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。



```
